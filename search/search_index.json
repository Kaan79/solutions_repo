{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Projectile Motion: A Theoretical and Computational Study 1. Introduction Projectile motion is a fundamental topic in classical mechanics that describes the motion of an object launched into the air, subject to gravitational acceleration. It plays a crucial role in understanding various real-world phenomena, from the trajectory of a thrown ball to the path of a rocket. The motion of a projectile can be decomposed into independent horizontal and vertical components, governed by well-established kinematic equations. These equations provide valuable insights into the relationship between velocity, acceleration, time, and displacement. This study aims to delve into the mathematical foundations of projectile motion, systematically deriving its governing equations from Newton\u2019s laws of motion. By exploring the dependence of range, time of flight, and maximum height on initial launch conditions, we will demonstrate how these factors interact to shape the projectile\u2019s path. Furthermore, we will analyze how variations in initial velocity, gravitational acceleration, and launch height influence the overall motion, leading to a diverse set of outcomes. A computational approach will be employed to simulate and visualize projectile trajectories, enabling a deeper understanding of the theoretical principles through numerical methods. By combining analytical derivations with computational techniques, we aim to bridge the gap between theoretical physics and real-world applications, demonstrating the practical significance of projectile motion across various disciplines, including sports, engineering, and astrophysics. 2. Governing Equations of Motion Projectile motion is governed by Newton\u2019s laws of motion. To describe its behavior, we break it down into two components: 2.1 Horizontal Motion In the absence of air resistance, the horizontal velocity remains constant since no horizontal force acts on the projectile: [ x = v_0 \\cos(\\theta) t ] Here, ( v_0 ) is the initial velocity, and ( theta ) is the launch angle. Since there is no acceleration in the horizontal direction, the velocity remains constant: [ v_x = v_0 \\cos(\\theta) ] 2.2 Vertical Motion The vertical motion is influenced by gravity, which causes a constant downward acceleration of ( g ). Using kinematic equations: [ y = y_0 + v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] The vertical velocity at any time ( t ) is given by: [ v_y = v_0 \\sin(\\theta) - g t ] The maximum height ( H ) occurs when ( v_y = 0 ): [ H = \\frac{(v_0 \\sin(\\theta))^2}{2g} ] The total time of flight ( T ) can be derived by setting ( y = 0 ) and solving for ( t ): [ T = \\frac{2 v_0 \\sin(\\theta)}{g} ] This breakdown allows us to predict the full trajectory of the projectile and analyze how various initial conditions influence the motion. 3. Analysis of Range Dependence on Launch Angle The horizontal range ( R ) is given by: [ R = \\frac{v_0^2 \\sin(2\\theta)}{g} ] The range is maximized when ( \\theta = 45^\\circ ). Increasing initial velocity increases the range quadratically. If the launch height is nonzero, the equation needs modifications. The following plot visualizes how the range changes with launch angle: import numpy as np import matplotlib.pyplot as plt def projectile_range(theta, v0, g=9.81): theta_rad = np.radians(theta) return (v0**2 * np.sin(2 * theta_rad)) / g angles = np.linspace(0, 90, 100) ranges = [projectile_range(theta, 20) for theta in angles] plt.figure(figsize=(10, 5)) plt.plot(angles, ranges, label='Range vs. Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Effect of Launch Angle on Range') plt.legend() plt.grid() plt.show() 4. Computational Implementation To better understand projectile motion, we implement a simulation using Python. The following code computes the trajectory for various launch angles and plots the results: import numpy as np import matplotlib.pyplot as plt def projectile_trajectory(theta, v0, g=9.81, dt=0.01): theta_rad = np.radians(theta) vx = v0 * np.cos(theta_rad) vy = v0 * np.sin(theta_rad) x, y = [0], [0] while y[-1] >= 0: vy = vy - g * dt # Vertical acceleration due to gravity x.append(x[-1] + vx * dt) y.append(y[-1] + vy * dt) return x, y angles = [30, 45, 60] plt.figure(figsize=(10, 5)) for angle in angles: x, y = projectile_trajectory(angle, 20) plt.plot(x, y, label=f'\u03b8 = {angle}\u00b0') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.title('Projectile Motion for Different Launch Angles') plt.legend() plt.grid() plt.show() This script simulates projectile motion and visualizes trajectories for different launch angles. The results confirm theoretical predictions. 5. Limitations and Further Considerations While our model provides a solid understanding of projectile motion, several real-world factors complicate the idealized equations: Air Resistance: The presence of drag alters the motion, making it non-parabolic. A more accurate model requires solving differential equations numerically. Wind Effects: External forces like wind can push the projectile off its ideal path. Non-Uniform Gravity: In planetary or space applications, gravity may not be constant. These factors make the real-world problem significantly more complex but also more accurate for practical applications like ballistics and aerospace engineering. 6. Conclusion Projectile motion, despite its seemingly simple nature, offers profound insights into fundamental physics. By deriving the governing equations and implementing computational simulations, we have explored the interplay between velocity, angle, and gravity. Our findings include: - The optimal angle for maximum range is 45\u00b0 . - Higher initial velocity increases range quadratically. - Computational simulations confirm theoretical predictions. Expanding this study to include air resistance, wind, and varying gravity would enhance realism, making it applicable to more complex scenarios in engineering and physics. This study serves as a bridge between theoretical physics and computational modeling, showcasing how fundamental equations can be applied to solve practical problems in various fields.","title":"Projectile Motion: A Theoretical and Computational Study"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-a-theoretical-and-computational-study","text":"","title":"Projectile Motion: A Theoretical and Computational Study"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction","text":"Projectile motion is a fundamental topic in classical mechanics that describes the motion of an object launched into the air, subject to gravitational acceleration. It plays a crucial role in understanding various real-world phenomena, from the trajectory of a thrown ball to the path of a rocket. The motion of a projectile can be decomposed into independent horizontal and vertical components, governed by well-established kinematic equations. These equations provide valuable insights into the relationship between velocity, acceleration, time, and displacement. This study aims to delve into the mathematical foundations of projectile motion, systematically deriving its governing equations from Newton\u2019s laws of motion. By exploring the dependence of range, time of flight, and maximum height on initial launch conditions, we will demonstrate how these factors interact to shape the projectile\u2019s path. Furthermore, we will analyze how variations in initial velocity, gravitational acceleration, and launch height influence the overall motion, leading to a diverse set of outcomes. A computational approach will be employed to simulate and visualize projectile trajectories, enabling a deeper understanding of the theoretical principles through numerical methods. By combining analytical derivations with computational techniques, we aim to bridge the gap between theoretical physics and real-world applications, demonstrating the practical significance of projectile motion across various disciplines, including sports, engineering, and astrophysics.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-governing-equations-of-motion","text":"Projectile motion is governed by Newton\u2019s laws of motion. To describe its behavior, we break it down into two components:","title":"2. Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-horizontal-motion","text":"In the absence of air resistance, the horizontal velocity remains constant since no horizontal force acts on the projectile: [ x = v_0 \\cos(\\theta) t ] Here, ( v_0 ) is the initial velocity, and ( theta ) is the launch angle. Since there is no acceleration in the horizontal direction, the velocity remains constant: [ v_x = v_0 \\cos(\\theta) ]","title":"2.1 Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-vertical-motion","text":"The vertical motion is influenced by gravity, which causes a constant downward acceleration of ( g ). Using kinematic equations: [ y = y_0 + v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] The vertical velocity at any time ( t ) is given by: [ v_y = v_0 \\sin(\\theta) - g t ] The maximum height ( H ) occurs when ( v_y = 0 ): [ H = \\frac{(v_0 \\sin(\\theta))^2}{2g} ] The total time of flight ( T ) can be derived by setting ( y = 0 ) and solving for ( t ): [ T = \\frac{2 v_0 \\sin(\\theta)}{g} ] This breakdown allows us to predict the full trajectory of the projectile and analyze how various initial conditions influence the motion.","title":"2.2 Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-analysis-of-range-dependence-on-launch-angle","text":"The horizontal range ( R ) is given by: [ R = \\frac{v_0^2 \\sin(2\\theta)}{g} ] The range is maximized when ( \\theta = 45^\\circ ). Increasing initial velocity increases the range quadratically. If the launch height is nonzero, the equation needs modifications. The following plot visualizes how the range changes with launch angle: import numpy as np import matplotlib.pyplot as plt def projectile_range(theta, v0, g=9.81): theta_rad = np.radians(theta) return (v0**2 * np.sin(2 * theta_rad)) / g angles = np.linspace(0, 90, 100) ranges = [projectile_range(theta, 20) for theta in angles] plt.figure(figsize=(10, 5)) plt.plot(angles, ranges, label='Range vs. Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Effect of Launch Angle on Range') plt.legend() plt.grid() plt.show()","title":"3. Analysis of Range Dependence on Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-computational-implementation","text":"To better understand projectile motion, we implement a simulation using Python. The following code computes the trajectory for various launch angles and plots the results: import numpy as np import matplotlib.pyplot as plt def projectile_trajectory(theta, v0, g=9.81, dt=0.01): theta_rad = np.radians(theta) vx = v0 * np.cos(theta_rad) vy = v0 * np.sin(theta_rad) x, y = [0], [0] while y[-1] >= 0: vy = vy - g * dt # Vertical acceleration due to gravity x.append(x[-1] + vx * dt) y.append(y[-1] + vy * dt) return x, y angles = [30, 45, 60] plt.figure(figsize=(10, 5)) for angle in angles: x, y = projectile_trajectory(angle, 20) plt.plot(x, y, label=f'\u03b8 = {angle}\u00b0') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.title('Projectile Motion for Different Launch Angles') plt.legend() plt.grid() plt.show() This script simulates projectile motion and visualizes trajectories for different launch angles. The results confirm theoretical predictions.","title":"4. Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-further-considerations","text":"While our model provides a solid understanding of projectile motion, several real-world factors complicate the idealized equations: Air Resistance: The presence of drag alters the motion, making it non-parabolic. A more accurate model requires solving differential equations numerically. Wind Effects: External forces like wind can push the projectile off its ideal path. Non-Uniform Gravity: In planetary or space applications, gravity may not be constant. These factors make the real-world problem significantly more complex but also more accurate for practical applications like ballistics and aerospace engineering.","title":"5. Limitations and Further Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-conclusion","text":"Projectile motion, despite its seemingly simple nature, offers profound insights into fundamental physics. By deriving the governing equations and implementing computational simulations, we have explored the interplay between velocity, angle, and gravity. Our findings include: - The optimal angle for maximum range is 45\u00b0 . - Higher initial velocity increases range quadratically. - Computational simulations confirm theoretical predictions. Expanding this study to include air resistance, wind, and varying gravity would enhance realism, making it applicable to more complex scenarios in engineering and physics. This study serves as a bridge between theoretical physics and computational modeling, showcasing how fundamental equations can be applied to solve practical problems in various fields.","title":"6. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Mathematical Analysis of the Forced Damped Pendulum 1. Theoretical Foundation A forced damped pendulum represents a system under the influence of an external force while experiencing frictional damping. The equation governing this system is: \\[ \\frac{d^2theta}{dt^2} + beta \\frac{dtheta}{dt} + \\frac{g}{L} sintheta = A cos(omega t) \\] Where: - ( \\theta ) : Angular position (in radians) - ( \\beta ) : Damping coefficient - ( g ) : Gravitational acceleration - ( L ) : Length of the pendulum - ( A ) : Amplitude of the external forcing - ( \\omega ) : Angular frequency of the external force Small-Angle Approximation If ( \\theta ) is small, we can use the approximation ( \\sin\\theta \\approx \\theta ), reducing the equation to: \\[ \\frac{d^2 theta}{dt^2} + beta \\frac{d theta}{dt} + \\frac{g}{L} theta = A cos(omega t) \\] This linear differential equation can be analyzed using analytical methods. 2. Analysis of Dynamics To understand the system's behavior, we analyze the following factors: Damping Coefficient (( \\beta )) : Determines how quickly oscillations diminish. Driving Force (( A )) and Frequency ( \\omega ) : Affect whether the system enters resonance or exhibits chaotic motion. Phase Transitions and Chaos : Under certain parameter values, the system may become chaotic. 3. Real-World Applications The forced damped pendulum model is applicable in various physical systems: - Energy Harvesting Devices - Oscillations in Bridges and Buildings - Electrical Circuits (e.g., RLC circuits) - Biomechanics (Human Motion) 4. Implementation: Python Simulation To observe the system's behavior over time, we can use Python to numerically solve the equations: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravitational acceleration (m/s^2) L = 1.0 # Pendulum length (m) beta = 0.2 # Damping coefficient A = 1.2 # Forcing amplitude omega = 2.0 # Forcing frequency def forced_damped_pendulum(t, y): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -beta * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions y0 = [0.2, 0.0] t_span = (0, 20) t_eval = np.linspace(t_span[0], t_span[1], 1000) # Solve the equation solution = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval) # Plot results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label='Angular Position (\u03b8)') plt.xlabel('Time (s)') plt.ylabel('\u03b8 (radians)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() 5. Phase Portraits and Chaos Transitions To analyze chaotic behavior, we can visualize phase portraits (Poincar\u00e9 sections). The following plot represents the phase space motion: plt.figure(figsize=(8, 6)) plt.plot(solution.y[0], solution.y[1], label='Phase Portrait') plt.xlabel('\u03b8 (radians)') plt.ylabel('d\u03b8/dt (Angular velocity)') plt.title('Phase Portrait') plt.legend() plt.grid() plt.show() 6. Conclusions and Insights Higher damping results in the system reaching equilibrium without oscillations. Near resonance frequency , large amplitude oscillations occur. Increasing forcing amplitude may lead to chaotic transitions. This analysis provides a powerful model for applications in engineering and natural sciences. By using Markdown, we can document and explore the pendulum system\u2019s dynamics in depth.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#mathematical-analysis-of-the-forced-damped-pendulum","text":"","title":"Mathematical Analysis of the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"A forced damped pendulum represents a system under the influence of an external force while experiencing frictional damping. The equation governing this system is: \\[ \\frac{d^2theta}{dt^2} + beta \\frac{dtheta}{dt} + \\frac{g}{L} sintheta = A cos(omega t) \\] Where: - ( \\theta ) : Angular position (in radians) - ( \\beta ) : Damping coefficient - ( g ) : Gravitational acceleration - ( L ) : Length of the pendulum - ( A ) : Amplitude of the external forcing - ( \\omega ) : Angular frequency of the external force","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"If ( \\theta ) is small, we can use the approximation ( \\sin\\theta \\approx \\theta ), reducing the equation to: \\[ \\frac{d^2 theta}{dt^2} + beta \\frac{d theta}{dt} + \\frac{g}{L} theta = A cos(omega t) \\] This linear differential equation can be analyzed using analytical methods.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"To understand the system's behavior, we analyze the following factors: Damping Coefficient (( \\beta )) : Determines how quickly oscillations diminish. Driving Force (( A )) and Frequency ( \\omega ) : Affect whether the system enters resonance or exhibits chaotic motion. Phase Transitions and Chaos : Under certain parameter values, the system may become chaotic.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"The forced damped pendulum model is applicable in various physical systems: - Energy Harvesting Devices - Oscillations in Bridges and Buildings - Electrical Circuits (e.g., RLC circuits) - Biomechanics (Human Motion)","title":"3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"To observe the system's behavior over time, we can use Python to numerically solve the equations: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravitational acceleration (m/s^2) L = 1.0 # Pendulum length (m) beta = 0.2 # Damping coefficient A = 1.2 # Forcing amplitude omega = 2.0 # Forcing frequency def forced_damped_pendulum(t, y): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -beta * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions y0 = [0.2, 0.0] t_span = (0, 20) t_eval = np.linspace(t_span[0], t_span[1], 1000) # Solve the equation solution = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval) # Plot results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label='Angular Position (\u03b8)') plt.xlabel('Time (s)') plt.ylabel('\u03b8 (radians)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show()","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-phase-portraits-and-chaos-transitions","text":"To analyze chaotic behavior, we can visualize phase portraits (Poincar\u00e9 sections). The following plot represents the phase space motion: plt.figure(figsize=(8, 6)) plt.plot(solution.y[0], solution.y[1], label='Phase Portrait') plt.xlabel('\u03b8 (radians)') plt.ylabel('d\u03b8/dt (Angular velocity)') plt.title('Phase Portrait') plt.legend() plt.grid() plt.show()","title":"5. Phase Portraits and Chaos Transitions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-conclusions-and-insights","text":"Higher damping results in the system reaching equilibrium without oscillations. Near resonance frequency , large amplitude oscillations occur. Increasing forcing amplitude may lead to chaotic transitions. This analysis provides a powerful model for applications in engineering and natural sciences. By using Markdown, we can document and explore the pendulum system\u2019s dynamics in depth.","title":"6. Conclusions and Insights"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem Deriving Kepler's Third Law for Circular Orbits 1. Theoretical Foundation Kepler's Third Law states that the square of a planet\u2019s orbital period is proportional to the cube of its orbital radius: \\[ T^2 propto R^3 \\] We derive this relationship using Newton's Law of Gravitation and circular motion dynamics. Newton's Law of Gravitation The gravitational force between two masses ( M ) and ( m ) is given by: \\[ F = \\frac{G M m}{R^2} \\] where: - ( G ) is the gravitational constant, - ( R ) is the orbital radius. For a circular orbit, the gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{R^2} = m \\frac{v^2}{R} \\] Canceling ( m ) and solving for orbital velocity ( v ): \\[ v^2 = \\frac{G M}{R} \\] Using the relation between velocity and period (( v = \\frac{2\\pi R}{T} )): \\[ left(\\frac{2pi R}{T}right)^2 = \\frac{G M}{R} \\] Rearranging: \\[ T^2 = \\frac{4 pi^2}{G M} R^3 \\] Thus, we confirm that ( T^2 \\propto R^3 ). 2. Implications for Astronomy Used to estimate planetary masses and distances. Helps predict satellite and exoplanet orbits. Important in celestial mechanics and space navigation. 3. Real-World Examples Moon's orbit around Earth : Applying Kepler\u2019s Law allows us to estimate the mass of Earth. Planets in the Solar System : All planets obey this law, confirming Newtonian gravity. 4. Python Simulation To verify the relationship, we simulate circular orbits. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 1.989e30 # Mass of the Sun (kg) # Define orbital radii (in AU, converted to meters) au = 1.496e11 # 1 Astronomical Unit in meters radii = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58, 19.18, 30.07]) * au # Compute periods using Kepler's Third Law periods = np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Convert periods to years periods_years = periods / (60 * 60 * 24 * 365) # Plot plt.figure(figsize=(8,6)) plt.loglog(radii/au, periods_years, 'bo-', label='Simulated Data') plt.xlabel('Orbital Radius (AU)') plt.ylabel('Orbital Period (years)') plt.title(\"Kepler's Third Law: T\u00b2 vs R\u00b3\") plt.legend() plt.grid(True, which='both', linestyle='--') plt.show() 5. Extending to Elliptical Orbits Kepler\u2019s law applies to elliptical orbits by considering the semi-major axis instead of the radius. Used in astrodynamics to analyze non-circular planetary motion. 6. Conclusion Kepler\u2019s Third Law is fundamental in celestial mechanics. Observational verification confirms Newtonian gravity. Extends to exoplanetary systems and astrophysics applications.","title":"Problem"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem","text":"","title":"Problem"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deriving-keplers-third-law-for-circular-orbits","text":"","title":"Deriving Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"Kepler's Third Law states that the square of a planet\u2019s orbital period is proportional to the cube of its orbital radius: \\[ T^2 propto R^3 \\] We derive this relationship using Newton's Law of Gravitation and circular motion dynamics.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-of-gravitation","text":"The gravitational force between two masses ( M ) and ( m ) is given by: \\[ F = \\frac{G M m}{R^2} \\] where: - ( G ) is the gravitational constant, - ( R ) is the orbital radius. For a circular orbit, the gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{R^2} = m \\frac{v^2}{R} \\] Canceling ( m ) and solving for orbital velocity ( v ): \\[ v^2 = \\frac{G M}{R} \\] Using the relation between velocity and period (( v = \\frac{2\\pi R}{T} )): \\[ left(\\frac{2pi R}{T}right)^2 = \\frac{G M}{R} \\] Rearranging: \\[ T^2 = \\frac{4 pi^2}{G M} R^3 \\] Thus, we confirm that ( T^2 \\propto R^3 ).","title":"Newton's Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Used to estimate planetary masses and distances. Helps predict satellite and exoplanet orbits. Important in celestial mechanics and space navigation.","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Moon's orbit around Earth : Applying Kepler\u2019s Law allows us to estimate the mass of Earth. Planets in the Solar System : All planets obey this law, confirming Newtonian gravity.","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-simulation","text":"To verify the relationship, we simulate circular orbits. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 1.989e30 # Mass of the Sun (kg) # Define orbital radii (in AU, converted to meters) au = 1.496e11 # 1 Astronomical Unit in meters radii = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58, 19.18, 30.07]) * au # Compute periods using Kepler's Third Law periods = np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Convert periods to years periods_years = periods / (60 * 60 * 24 * 365) # Plot plt.figure(figsize=(8,6)) plt.loglog(radii/au, periods_years, 'bo-', label='Simulated Data') plt.xlabel('Orbital Radius (AU)') plt.ylabel('Orbital Period (years)') plt.title(\"Kepler's Third Law: T\u00b2 vs R\u00b3\") plt.legend() plt.grid(True, which='both', linestyle='--') plt.show()","title":"4. Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extending-to-elliptical-orbits","text":"Kepler\u2019s law applies to elliptical orbits by considering the semi-major axis instead of the radius. Used in astrodynamics to analyze non-circular planetary motion.","title":"5. Extending to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-conclusion","text":"Kepler\u2019s Third Law is fundamental in celestial mechanics. Observational verification confirms Newtonian gravity. Extends to exoplanetary systems and astrophysics applications.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}